# Pre-Update Issue Report (v1.00)

## Executive Summary
The v1.00 evaluation cycle surfaced critical blockers across the backend API, database migrations, dependency stack, web client, and Flutter user app. Secrets are fetched during module import, duplicated routers remap the public surface, JWT verification downgrades on error, and readiness probes mutate PostGIS extensions even when credentials forbid it. Finance and communications migrations deploy destructive cascades, randomised seed data, and unbounded JSON metadata without audit or idempotency controls. Dependency manifests are malformed, mix incompatible stacks (MapLibre + Mapbox Draw), and depend on beta/binary packages that cannot build reliably in CI. The React dashboard trusts `localStorage` for personas, exposes admin panels to unauthenticated visitors, and crashes en masse because a single `Suspense` boundary wraps seventy lazy routes. The Flutter build still hinges on demo tokens, blocks rendering behind sequential bootstrap work, hardcodes stale app versions, and fires crash telemetry to nonexistent endpoints without awaiting delivery. Without coordinated remediation, the update cannot reach staging.

## Backend Assessment
### Boot & Configuration Safety
The Express gateway mounts several routers (`walletRoutes`, `servicemanRoutes`, `servicemanControlRoutes`) multiple times and remaps `v1` traffic to `/`, so middleware ordering and versioned contracts cannot be trusted. Secrets loading, PII configuration, and job schedulers execute during module import inside `config/index.js` and `app.js`, turning transient AWS Secrets Manager latency or missing env vars into fatal boot crashes before logging starts. `server.js` immediately calls `start()` and later forces `process.exit(...)`, preventing tests and orchestrators from staging listeners or inspecting failures, while readiness checks mutate PostGIS extensions during every probe.

### Authentication & Transport Controls
`verifyAccessToken` falls back to decoding any shared-secret token regardless of issuer or audience, the storefront override header (`x-fixnado-role`) is only gated by `NODE_ENV === 'test'`, and CORS reflects every origin while enabling credentials. Helmet ships with CSP/COEP disabled, leaving script execution wide open. The authentication middleware double returns in the missing-token branch, suppressing guidance for legitimate storefront users, and secrets bootstrap prints stack traces—including AWS metadata—to stdout.

### Reliability, Operations & Observability
Readiness relies on synchronous PostGIS extension creation, so managed Postgres tiers without superuser rights enter reboot loops. Background jobs for analytics, credential rotation, and notifications autostart in every environment without feature gates or leader election, multiplying load in blue/green deployments. Rate limiting omits `Retry-After` headers and its custom key generator throws when the configured IP header is absent, amplifying the very denial-of-service conditions it aims to prevent. Telemetry ingestion routes exist only for UI preferences; `/telemetry/client-errors` and `/telemetry/mobile-crashes` 404, the rate limiter emits no structured metrics, and `measureDatabaseHealth` discards stack traces, hampering incident response.

### Integration & Roadmap Alignment
Migrations insert synthetic ledger events, seed communications settings with random UUIDs, and assume GIS support even though the service advertises pluggable dialects. Router sprawl exposes finance, escrow, and serviceman control domains without feature toggles, conflicting with the narrower scope expected for v1.00.

## Database Assessment
Finance and communications migrations deploy hundreds of lines of DDL without `sequelize.transaction()` wrappers, so any mid-migration failure leaves dangling foreign keys, destroyed enums, and partially created tables. Cascade deletes from users, services, and orders erase immutable ledgers; webhook events and notification recipients lack idempotency keys; and amount columns accept negative values with no CHECK constraints. Enum types are unnamespaced, down migrations drop them without `IF EXISTS`, and readiness probes crash when PostGIS privileges are missing. Seed data relies on `randomUUID()`, blocking deterministic replays, while communications settings enforce one configuration per tenant, ignore audit metadata, and store `allowed_roles` as unvalidated JSON. Index coverage is thin—`payout_requests` lacks `provider_id` indices, webhook retries scan entire tables, and communications entry points miss partial indexes for enabled records. Sensitive payment payloads persist indefinitely in JSONB columns with no retention or encryption hooks, clashing with compliance requirements.

## Dependency Assessment
`backend-nodejs/package.json` is syntactically invalid because dependency keys repeat and commas are misplaced, preventing npm installs and masking drift. The backend combines `dotenv@17` (ESM-only), `sqlite3` (native build), `bcrypt@6` (beta), and `@aws-sdk/client-secrets-manager@3.585.0` (Node 18+) without documenting runtime constraints, so CI pipelines break unpredictably. Scripts assume globally installed `k6`, yet no guard checks for its presence. The React app simultaneously jumps to Vite 6, React 18.3, MapLibre 5, and Mapbox Draw 1.5—an unsupported mix that inflates bundles and risks runtime crashes. Flutter lockfiles were edited manually, biometric plugins require elevated Android SDK levels, and no project defines `engines` or SDK ranges, leaving teams unaware of supported platforms. License and security audit tooling exists but is disconnected from review workflows, so risky upgrades land silently.

## Front-end Assessment
The dashboard mounts more than seventy lazy routes inside one `Suspense` boundary; a single failed import blanks the entire app. Session bootstrap trusts a fallback stub stored in `localStorage`, never revalidates `/api/auth/me`, and mutates persona unlocks client-side, allowing unauthenticated visitors to grant themselves provider dashboards. `ProviderProtectedRoute` presents denial copy but never redirects users to onboarding, localization failures render blank pages, and authenticated layouts hide legal footers that enterprise admins still require. Error boundaries leak stack traces and URLs to end users while crash telemetry targets a missing backend handler, so incidents are both exposed and invisible. Global widgets (chat, analytics) mount for every persona, rehydrating heavy modules even when not needed, and storage corruption loops indefinitely without recovery flows.

## User App Assessment
`AuthGate` still lacks a credentialed login for existing users, relying on `demoAccessToken` fixtures that are stored like production credentials. Bootstrap work (preferences, secure storage, biometrics) runs sequentially on the UI thread, producing long blank screens and crashes when plugins misbehave. `AppDiagnosticsReporter` hardcodes `appVersion: '1.50'`, posts plaintext stack traces to `/telemetry/mobile-crashes`—which the backend does not implement—reuses a single HTTP client without backoff, and never awaits uploads. `AuthTokenController.ensureFreshness` swallows refresh errors, `IndexedStack` keeps every tab alive, and the API client lacks retry or pagination support, so transient backend issues surface as fatal user-visible states. Environment selection is compile-time only, forcing rebuilds for staging, and no integration or golden tests enforce regression coverage.

## Cross-Cutting Delivery Risks
Telemetry endpoints are absent, rate limiting and boot diagnostics emit only console logs, and correlation IDs are not propagated across tiers. Dependency stacks demand Node 18+, Android SDK 23+, and native toolchains, yet onboarding guides omit prerequisites and automation to enforce them. Background jobs, migrations, and offline fallbacks all run by default without feature flags, making blue/green deployments or demo builds dangerous. Provider-specific mobile apps are not present in this repository, so the Flutter user app is the sole mobile surface under review; nevertheless, its reliance on demo flows and missing telemetry prevent production launch.
