# Pre-Update Issue Report (v1.00)

## Executive Summary
The v1.00 readiness review uncovered systemic authentication weaknesses, brittle database migrations, and platform-specific UX regressions that block a safe rollout. Both the web and mobile clients rely on optimistic session stubs that bypass real credential validation, while the backend accepts any JWT signed with the shared secret regardless of issuer. Simultaneously, finance and communications schema changes deploy as a single unguarded migration batch with destructive cascades that can erase ledger history. Build hygiene is also compromised: the backend `package.json` is syntactically invalid, background jobs auto-start in every environment, the API reflects cookies to any origin by default, and the React dashboard trusts `localStorage` persona unlocks—letting any visitor elevate access without server approval. Telemetry blind spots compound the risk because client error and mobile crash reports 404 before reaching operators.

## Key Findings by Track
- **Backend** – Duplicate router mounts, eager secrets loading, permissive JWT verification, and wildcard CORS all erode reliability and security. Background jobs launch without coordination, `server.js` force-exits on boot errors, and there is no `/telemetry/client-errors` ingestion path, making controlled rollouts and monitoring difficult. (`backend-nodejs/src/routes/index.js`, `backend-nodejs/src/config/index.js`, `backend-nodejs/src/services/sessionService.js`, `backend-nodejs/src/app.js`, `backend-nodejs/src/jobs/index.js`, `backend-nodejs/src/server.js`, `backend-nodejs/src/routes/telemetryRoutes.js`).
- **Database** – Finance/communications migrations run without transactions, seed non-deterministic data, and cascade deletes through payments, destroying audit history while omitting provider-focused indexes. (`backend-nodejs/src/database/migrations/20250325000000-payments-orchestration.js`, `backend-nodejs/src/database/migrations/20250327000000-create-communications-inbox-settings.js`).
- **Front-end** – A single `App.jsx` hosts dozens of lazy routes under one suspense boundary, while the session hook trusts localStorage without revalidation and the dashboard hub lets anyone unlock personas client-side. Error boundaries also leak full stack traces to end users and the crash reporter points at a dead backend route, leaving monitoring silent during outages. (`frontend-reactjs/src/App.jsx`, `frontend-reactjs/src/hooks/useSession.js`, `frontend-reactjs/src/pages/DashboardHub.jsx`, `frontend-reactjs/src/components/error/AppErrorBoundary.jsx`, `frontend-reactjs/src/utils/errorReporting.js`).
- **User App** – Flutter bootstrap lacks credential login, performs sequential blocking IO, and downplays telemetry, leaving real users unable to authenticate and support teams blind during crashes. Crash reporting also relies on `unawaited` network calls and targets an unimplemented `/telemetry/mobile-crashes` endpoint. (`flutter-phoneapp/lib/features/auth/presentation/auth_gate.dart`, `flutter-phoneapp/lib/app/bootstrap.dart`, `flutter-phoneapp/lib/core/diagnostics/app_diagnostics_reporter.dart`, `flutter-phoneapp/lib/main.dart`, `backend-nodejs/src/routes/telemetryRoutes.js`).
- **Dependencies** – Duplicate keys and aggressive framework upgrades break installs and stretch runtime compatibility across the stack without guardrails; MapLibre/Mapbox Draw mismatches and hand-authored lockfiles add more risk. (`backend-nodejs/package.json`, `frontend-reactjs/package.json`, `flutter-phoneapp/pubspec.lock`).

## Recommended Next Steps
1. Lock down authentication end-to-end: enforce strict JWT validation, add `/api/auth/me` revalidation in web, move persona unlock logic server-side, and ship proper credential flows on mobile.
2. Refactor the payments/communications migrations into transactional, independently deployable units with deterministic seeds, non-destructive cascades, and provider indexes.
3. Repair dependency manifests, add CI checks for syntax/regressions, and introduce telemetry/bundle analysis so performance regressions surface earlier—while validating lockfiles and incompatible library pairings.
4. Gate long-running background jobs, tighten default CORS/Helmet settings, decouple `server.js` startup from auto-listening, and lazy load optional UI modules to reduce cold starts and limit failure cascades during rollout.
5. Stand up shared telemetry ingestion for browser and mobile crashes with retention policies so operators regain visibility into production failures.

Addressing these items is prerequisite to promoting the v1.00 update into staging. Follow-on work should focus on observability (structured logs, crash metadata) and roadmap alignment (rebalancing scope toward booking flows).
