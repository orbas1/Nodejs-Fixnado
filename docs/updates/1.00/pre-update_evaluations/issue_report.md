# Pre-Update Issue Report (v1.00)

## Executive Summary
Across the v1.00 pre-update evaluations we observed systemic release blockers that compromise security, data integrity, and operability for every surface (backend API, database, web dashboard, Flutter user app, and shared tooling). Authentication is dangerously permissive: the backend accepts any JWT signed with the shared secret regardless of issuer, the React dashboard treats `localStorage` mutations as authority, and the mobile app still boots exclusively with demo tokens while storing them alongside production credentials. Database migrations attempt to deliver expansive finance and communications schemas in a single, non-transactional batch that seeds destructive cascading deletes, inserts synthetic bootstrap ledgers with no provenance, and leaves enum rollbacks impossible. Tooling collapses under its own weight—`backend-nodejs/package.json` is invalid JSON, Node/Flutter lockfiles are hand-edited, native prerequisites are undocumented, and scripts assume global binaries. The platform also lacks foundational operability: readiness probes try to `CREATE EXTENSION postgis` on every boot, telemetry routers omit promised crash ingestion handlers, the dashboard shows raw stack traces, and Flutter’s crash reporter still hardcodes `appVersion: '1.50'`. Unless these issues are addressed before cutting the release branch, v1.00 will ship with trivial account takeover vectors, high probability of data loss, platform-specific boot loops, and no observability to diagnose the fallout.

## Backend API
The Express service currently operates with duplicated router mounts (`walletRoutes`, `servicemanRoutes`, `servicemanControlRoutes`) that are registered multiple times in the aggregated router. Besides doubling middleware work and inflating startup time, the duplication makes route-level guards non-deterministic, enabling bypasses of versioned prefixes and allowing legacy URLs (remounted at `/`) to short-circuit version negotiation. Bootstrapping is brittle end to end: secrets are fetched at module import through `loadSecretsIntoEnv` with no retry or structured logging, `assertPiiConfiguration()` throws before the logger is initialised, readiness bootstraps attempt to install PostGIS extensions regardless of permissions, and `server.js` immediately starts listening and launches background jobs on import—eliminating the ability to coordinate blue/green rollouts, inject test configuration, or await feature flag resolution. Security posture is untenable. `verifyAccessToken` silently falls back to a permissive decode path whenever verification fails, so any token signed with the shared secret is treated as authentic even if issuer, audience, or expiry are wrong. The authentication middleware accepts header-based impersonation whenever `NODE_ENV !== 'production'`, CORS reflects any origin while still sending credentials, Helmet disables both CSP and COEP, and `authenticate` returns twice, hiding correct failure messaging. Operational guardrails are similarly weak: the custom rate limiter key generator can throw for unset headers, throttles omit the standard `Retry-After` header, background jobs start in every pod without coordination, and graceful shutdown culminates in `process.exit`, preventing orchestrators from capturing diagnostics. Finally, the telemetry router only exposes `/telemetry/ui-preferences`; the promised `/telemetry/client-errors` and `/telemetry/mobile-crashes` handlers are missing, so client crash reports receive 404 responses while error boundaries continue to surface raw stack traces to end users.

## Database Layer
The payments orchestration migration chains dozens of DDL statements—creating four new tables, adding nine foreign keys, seeding bootstrap rows, and introducing enums—without wrapping them in a transaction. A mid-flight failure leaves dangling types and partially applied tables, yet the down migration still attempts to drop enums without `IF EXISTS`, guaranteeing rollback errors and stranding environments in half-migrated states. Schema design choices are hazardous. Core finance tables cascade deletes to users, orders, and regions, erasing immutable ledgers whenever upstream entities are removed, while nullable `gateway_reference` columns and absent idempotency keys invite duplicate payment events. Communications inbox settings assume a single configuration per tenant even though the roadmap calls for multi-brand support, and they persist loosely validated JSON (`allowed_roles`, metadata) with no schema enforcement, actor attribution, or retention guardrails. Critical constraints are absent across the board: notification recipients lack uniqueness on `(account_setting_id, channel, target)`, webhook tables omit conflict handling and provider indexes, amount fields accept negative values with no currency validation, and bootstrap rows rely on `randomUUID()`, ensuring every environment diverges. Seeding relies on unstructured JSON defaults, there is no seeded quick-reply content, and rollback scripts ignore index cleanup. Index coverage is thin—`payout_requests` never indexes `provider_id`, webhook queries lack `provider` filters, communications entry points skip partial indexes on `enabled = true`, and audit trails omit `created_by`/`updated_by`, setting the stage for slow queries and opaque provenance once data volume increases.

## Front-end Web Dashboard
`App.jsx` centralises more than seventy lazy routes and wraps them in a single Suspense boundary. If any module fails to load, the entire dashboard blanks with only a spinner fallback, tree-shaking cannot prune unused provider panels, and the build still ships dead routes meant for prototypes. Access control is almost entirely client-driven: `DashboardHub` mutates `localStorage` to grant persona access, `useSession` never revalidates against `/api/auth/me`, offline helpers silently reuse cached credentials, and corrupted storage is retained even after JSON parse errors, allowing trivial role escalation or storage tampering. The `ProviderProtectedRoute` component renders detailed denial messaging but never redirects to onboarding flows or throttles retries, so legitimate providers are stranded while attackers enumerate roles. UX and localisation polish regressed as well—legal footers disappear post-login, navigation contains duplicate entries due to case-sensitive merges, translation keys lack fallbacks, and the Suspense fallback is a bare spinner that leaves slow connections feeling frozen. Error boundaries surface raw stack traces and feed them into a telemetry endpoint that 404s, guaranteeing that critical failures remain invisible to support teams while leaking sensitive implementation details.

### Provider and Operations Personas
There is no dedicated “provider app” in the repository; the provider experience lives inside the React dashboard. Provider-focused routes depend on backend panels that are mounted multiple times or behind missing middleware, so even after the client self-unlocks dashboards, the API may respond with 404s or inconsistent role gating. Persona unlock flows fire no analytics, and onboarding states never surface remediation guidance, leaving provider rollout success entirely unmeasured. Until server-driven persona assignment, audited unlock APIs, and progressive disclosure of provider features are implemented, the provider experience remains a high-risk release component.

## Flutter User Application
The user app remains in a prototype state for authentication. `AuthGate` only handles demo sign-up flows seeded by `demoAccessToken`, `AuthTokenController.ensureFreshness` swallows refresh failures, and biometric fallbacks quietly store plaintext tokens if secure storage is unavailable. There is no path for returning users to re-authenticate, and credential demos share the same secure storage lifetime as production tokens. Cold-start UX is poor because bootstrap logic performs sequential secure storage and biometrics checks before rendering any splash screen, navigation keeps every tab alive in an `IndexedStack`, and the shell never remembers the last selected destination—forcing redundant rebuilds and network calls on low-end devices. Crash diagnostics are misconfigured end to end: the reporter hardcodes `appVersion: '1.50'`, logs verbose stack traces in release builds, transmits over plain HTTP if the base URL lacks TLS, omits device locale/build flavour, and fires uploads via `unawaited`, so process exits drop reports. The backend endpoint it targets (`/telemetry/mobile-crashes`) does not exist, making automated crash capture impossible, and bootstrap catches no exceptions when plugins fail—so a misconfigured biometric module crashes before telemetry initialises. Finally, the networking layer lacks retry/backoff behaviour, the API client eagerly decodes entire payloads into memory, and there is no runtime environment picker, so QA cannot swap staging/production without a rebuild.

## Dependencies, Tooling, and Build Health
Dependency hygiene is in crisis. `backend-nodejs/package.json` is malformed JSON with duplicate keys and missing commas, so `npm install` fails outright and hides real version drift. The manifest also mixes experimental `bcrypt@6` and `jsonwebtoken@9` without required hardening (e.g., `clockTolerance`), retains native modules such as `sqlite3` that require bespoke compiler toolchains, and leans on `dotenv@17` (ESM only) despite CommonJS helpers that `require('dotenv')`. The front-end pins `react@18.3.1` alongside older charting libraries (`recharts@2.12.7`) and MapLibre/Mapbox Draw combinations that are incompatible, while simultaneously jumping to `vite@6` and shipping both `@turf/turf` and `@turf/bbox`, forcing an abrupt Node 18+ adoption curve and bloating bundles. Flutter dependencies are manually edited in `pubspec.lock`, undermining reproducibility, demanding native biometrics setup on every contributor laptop, and omitting any documented Gradle/iOS prerequisites. Tooling scripts assume global binaries (`k6`), lockfiles are unchecked in CI, security audit scripts are disconnected from pull requests, and no package declares `engines` metadata. The result is an ecosystem where fresh clones cannot even install dependencies, much less run tests or builds, developers chase missing native toolchains, and audit/legal requirements remain invisible.

## Cross-Cutting Observability and Governance
Every tier fails to emit reliable telemetry. The backend omits ingestion endpoints and structured startup/shutdown logs, readiness only updates in memory, rate limiting emits no metrics, and Secrets Manager failures leak stack traces to stdout. The web app’s crash reporter speaks to a dead route, exposes stack traces directly to end users, and tracks no persona unlock analytics; the Flutter app drops crash uploads before exit and logs verbose traces in release builds. Audit trails are equally sparse: finance migrations insert bootstrap ledger rows with no actor attribution, communications settings capture privileged `allowed_roles` without `created_by`, and session events lack structured security logging. Governance processes are immature—security audit scripts exist but are not wired into CI, dependency choices and experimental upgrades are undocumented, and roadmap alignment has drifted toward delivering massive finance/provider expansions despite the stated goal of hardening authentication, booking flows, and telemetry first. Without disciplined prioritisation, runtime observability, and dependency governance, leadership cannot judge release readiness or respond to incidents.

## Priority Outcomes Before Release
1. **Seal authentication boundaries** by enforcing strict JWT validation, server-driven persona grants, and production-ready credential flows across web and mobile clients.
2. **Stabilise migrations and data contracts** through transactional execution, safe defaults, idempotency keys, and removal of destructive cascades so finance and communications records remain authoritative.
3. **Restore build viability** by fixing dependency manifests, aligning runtime baselines, and instituting automated governance (linting, audits, lockfile checks) so the toolchain is trustworthy.
4. **Stand up observability plumbing**—implement telemetry ingestion routes, await crash uploads, emit structured logs/metrics—and provide actionable error surfaces to users and operators.
5. **Re-scope release content** to focus on authentication, booking, and stability rather than launching incomplete provider analytics that depend on unfinished infrastructure.
