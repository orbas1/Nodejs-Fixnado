# Backend Pre-Update Evaluation – Version 1.50

## Functionality
- **High – Coverage gaps for roadmap features**: The Express routers under `backend-nodejs/src/routes/` still expose the 1.00 marketplace surface area. There are no endpoints or service-layer contracts for compliance review queues, moderation dispute resolution, or regional marketplace configuration. Without these APIs, the front-end and mobile workstreams cannot integrate or demo 1.50 capabilities.
- **High – Background processing not future-proofed**: `src/jobs/analyticsIngestionJob.js` continues to assume the legacy analytics payload. The new telemetry schema introduces nested `session.analytics.context` objects that will be dropped silently. We need schema negotiation, DLQ routing, and backfill scripts to avoid data loss when the richer events arrive.
- **High – Entry gateway lacks request governance**: `src/app.js` mounts the entire router under `/api` with default body parsers, no payload limits, and no rate limiting. Coupled with the monolithic router in `src/routes/index.js`, any brute-force or oversized payload can starve unrelated domains. Introduce scoped routers, payload caps, and middleware such as `express-rate-limit` before exposing 1.50 endpoints.
- **High – API surface lacks context and versioning**: `src/routes/index.js` mounts every router on `/api` without versioning or bounded contexts. Large modules such as bookings, campaigns, and analytics all share the same namespace, so introducing breaking changes for 1.50 will ripple to existing clients. Introduce `/v1`, `/v2` namespaces and domain gateways before expanding.
- **Medium – Infrastructure bootstrap inflexibility**: Provisioning scripts in `scripts/` bootstrap only a single-tenant US region. The 1.50 rollout introduces EU and APAC regions, but the scripts lack parameterisation for regional seeds, queue namespaces, and CDN origins. This will block staging parity until addressed.
- **Medium – Background job lifecycle unmanaged**: `src/server.js` calls `startBackgroundJobs` from `src/jobs/index.js` and then drops the returned handles. There is no stop/shutdown orchestration, no health exposure, and no retry budget governance, so operators cannot drain or inspect the workers during deploys.
- **Medium – Feature flagging deficit**: There is no centralised feature flag evaluation for the new marketplace guardrails. Services manually read environment variables, making it impossible to run blue/green or phased rollouts.
- **Medium – Reporting APIs missing**: Product analytics requires aggregated KPI endpoints for the executive dashboards. No `/analytics/` endpoints exist beyond historical exports, forcing stakeholders to rely on manual SQL.
- **Low – Server lifecycle gaps**: `src/server.js` immediately starts background jobs via `startBackgroundJobs` but never retains the handles for graceful shutdown or health checks. Rolling restarts will leak timers and can leave jobs running against drained databases.
- **Low – Operational automation backlog**: Scheduled jobs (cron definitions, queue consumers) are not codified in IaC. Manual configuration will be required for every environment spin-up, increasing deployment risk.

## Usability
- **High – Developer onboarding friction**: Engineers still create `.env` files manually, including secrets for Stripe, Twilio, SendGrid, and internal OAuth providers. Missing any variable leads to opaque runtime crashes. Ship an `.env.example` generator with sane defaults and mock credentials.
- **Medium – Poor API discoverability**: There is no OpenAPI spec or TypeDoc reference for the REST surface. New team members rely on tribal knowledge to discover available handlers. Adopt Swagger UI or `express-openapi-validator` with automated spec generation during CI.
- **Medium – Observability experience**: Logging remains string-based `console.log` calls. There is no correlation ID support or structured logging, making cross-service tracing nearly impossible. Introduce `pino` or `winston` with JSON output and propagation of request IDs.
- **Medium – Local environment drift**: Docker Compose files diverge from production (missing background workers, mock services). Engineers cannot reproduce production-like behaviour when debugging. Provide parity Compose stacks with fixture data.
- **Medium – Configuration opacity**: `src/config/index.js` spreads hundreds of environment toggles across nested objects without documentation or defaults per environment. Engineers cannot tell which values are required for staging versus production, and the defaults still reference placeholder API keys.
- **Low – Divergent bootstrap tooling**: `backend-nodejs/sql/install.sql` still provisions MySQL schemas and a `change_me` password even though production targets Postgres. New engineers follow the script and end up with misaligned local stacks and default credentials lingering in dev databases.
- **Low – Local DX gaps**: Seed scripts require developers to manually run multiple npm tasks. Provide a single `npm run dev:bootstrap` that orchestrates migrations, seeds, and fixture data.
- **Low – Runtime health visibility**: Neither `server.js` nor `app.js` exposes `/healthz` or `/readyz` endpoints. Operators must infer readiness from logs, which slows triage during deploys.

## Errors
- **High – Unbounded promise rejection risk**: Services such as `communicationsService` and `campaignService` run sequential async loops without protective `try/catch` blocks. In Node 18+, unhandled rejections terminate the process, jeopardising uptime. Introduce scoped error handling and instrumented retries.
- **High – Migration rollback instability**: Down migrations under `src/database/migrations` do not rehydrate enums, composite indexes, or seed data. QA environments frequently need rollback testing; without reliable reversibility we risk inconsistent database states.
- **Medium – Validation weaknesses**: Controllers accept payloads with minimal schema validation (e.g., zone, compliance, and service controllers). Invalid currencies and pricing tiers leak through to Sequelize, producing 500 errors. Adopt Joi/Zod validation and align DTOs with DB constraints.
- **Medium – Rate limiting absent**: Public endpoints lack rate limiting middleware. Brute-force abuse could generate cascading failures or degrade API availability.
- **Low – Monitoring blind spots**: There is limited alerting for job failures or queue backlogs. Failed jobs can linger for days before manual discovery. Instrument metrics exporters and automated paging thresholds.
- **Low – Job teardown ignorance**: Because the handles returned from `startBackgroundJobs` are never tracked, failed timers throw unhandled rejections during shutdown and we lose the ability to perform targeted retries or drains.
- **Low – Graceful shutdown missing**: Neither `server.js` nor `startBackgroundJobs` listens for `SIGTERM`/`SIGINT`. During deployments the process will exit mid-request and the job timers will continue touching databases until Node terminates, risking partial writes.

## Integration
- **High – Payment provider scaling concerns**: Stripe and escrow webhooks are processed synchronously on the main thread, performing fraud checks and ledger writes within the request lifecycle. This breaches Stripe's 3-second SLA and risks repeated webhook retries. Implement queue-backed processing with idempotency keys.
- **Medium – Search/Indexing fragility**: When `ELASTICSEARCH_URL` is undefined, the code still attempts to instantiate clients, triggering runtime errors. Provide guards and fallbacks so non-search deployments do not crash.
- **Medium – Overly permissive cross-origin access**: The blanket `cors()` call in `src/app.js` exposes administrative endpoints to any origin once a bearer token leaks. Without origin allowlists or a gateway layer we cannot run limited pilots safely.
- **Medium – Notification orchestration gaps**: SMTP and SMS integrations have no provider-level rate limiting or dead-letter queues. High-volume campaigns will fail silently once providers throttle requests. Add queued sending, provider health checks, and retry policies.
- **Medium – Partner API drift**: The integrations layer does not yet accommodate the updated logistics partner API required for international deliveries. Schema mismatches will break new marketplace lanes until adapters are built.
- **Low – External analytics**: Segment/Amplitude exports are stubbed but not wired. Marketing stakeholders will not receive the data needed for campaign measurement unless we finish the integration.
- **Low – Node fetch assumptions**: `src/jobs/analyticsIngestionJob.js` depends on the global `fetch` API without polyfills or availability checks. CI runners still use Node 18.17 where `fetch` is experimental; when disabled, the job throws before handling retries.

## Security
- **High – Secrets management debt**: Sensitive credentials are spread across `.env` files and CI variables without central governance. We need vault-backed secret distribution (AWS Secrets Manager, Hashicorp Vault) plus rotation policies before onboarding new regions.
- **High – Input sanitisation gaps**: HTML-rich fields (service descriptions, moderation notes) are stored and rendered without sanitisation. This leaves the admin console and emails vulnerable to stored XSS. Integrate sanitisation libraries (DOMPurify/server-side) and enforce allowlists.
- **High – Default secrets committed**: `src/config/index.js` ships hard-coded defaults for JWT secrets, SMTP passwords, and third-party API keys. Teams frequently copy these into staging, creating predictable credentials across environments.
- **High – Default install credentials linger**: `backend-nodejs/sql/install.sql` creates a MySQL user named `fixnado_user` with the password `change_me`, encouraging teams to share credentials across stacks and normalising predictable secrets even in local demos.
- **Medium – Helmet configuration weakened**: To keep legacy widgets working, `src/app.js` disables Helmet's CSP and cross-origin embedder policies without replacing them upstream. Until reverse proxies inject strict CSP headers we remain exposed to script injection and clickjacking.
- **Medium – Token lifecycle weaknesses**: Refresh tokens remain long-lived JWTs without server-side revocation. Implement a refresh token store, rotation on every use, and device-level revocation endpoints.
- **Medium – Audit logging**: Security-sensitive actions (role changes, payout approvals) are not auditable. Add structured audit logs and ensure they are immutable and retained per compliance requirements.
- **Low – Permission boundary clarity**: Role-based access checks are scattered across controllers. Consolidate policy enforcement via a central authorisation layer to reduce mistakes and ease audits.
- **Low – Transport security gaps**: `app.js` enables CORS for all origins without TLS enforcement or rate-limiting, making the API susceptible to abuse if tokens leak.

## Alignment
- **High – Product roadmap misalignment**: 1.50 features—regional marketplace, compliance review tools, analytics drill-downs—lack backend support. Without sprint reprioritisation the release scope cannot be met.
- **Medium – Contract governance**: The backend has not produced updated TypeScript definitions or JSON schemas for new analytics widgets, leading to divergence from the React and Flutter clients. Establish contract testing and publish shared schemas.
- **Medium – Operational readiness**: Runbooks, on-call procedures, and alerting thresholds still reflect 1.00 traffic profiles. Expand SLO definitions, add synthetic monitoring, and update incident response documentation before scaling to new regions.
- **Low – Compliance commitments**: Regulatory requirements (GDPR data subject rights, SOC 2 audit logs) are not captured in backlog epics. Align compliance deliverables with release gating.
- **Low – Data model drift**: `src/models/index.js` still models a single marketplace without `regionId` associations or governance tables, so even if APIs land, the ORM cannot represent the multi-region roadmap without invasive refactors.
