# Version 1.50 Pre-Update Issue Report

## Backend Platform
The backend codebase is materially behind the 1.50 roadmap. Critical functionality for compliance workflows, regional marketplace configuration, and executive analytics endpoints is absent, leaving product-critical features without server-side support. Background processing is brittle; analytics ingestion assumes the legacy schema, webhook handlers execute synchronously, and no feature flagging exists to govern phased rollouts. The API surface is also monolithic—`src/routes/index.js` mounts every domain on `/api` with no versioning and `src/app.js` exposes them with default body parsers, unlimited payload sizes, and permissive `cors()` defaults, forcing existing clients to absorb breaking changes while opening the door to brute-force abuse. Operational automation is sparse, with cron schedules and queue consumers configured manually, raising deployment risk across regions, and `src/server.js` launches jobs without graceful shutdown hooks, leading to timer leaks during deploys. Usability concerns include opaque onboarding (manual `.env` scaffolding), lack of API documentation, default secrets lingering in `src/config/index.js`, and conflicting bootstrap scripts—`backend-nodejs/sql/install.sql` still provisions MySQL users with the password `change_me`, causing local drift and normalising predictable credentials. Error handling remains fragile: unguarded promise chains risk process crashes, migrations are not reversible, validation is superficial, and monitoring lacks proactive alerting. Integrations with Stripe, search, notifications, and logistics partners are either synchronous or incomplete, leading to potential SLA violations, while analytics ingestion still assumes the global `fetch` API is available in every runtime. Security posture is weak due to unmanaged secrets, unsanitised HTML payloads, long-lived refresh tokens, and fragmented authorisation rules. Finally, the backend is misaligned with organisational commitments—contract schemas are unpublished, runbooks are stale, the ORM models in `src/models/index.js` still reflect a single-region design, and compliance obligations are missing from the release backlog.

## Dependency Landscape
Across the monorepo, dependency management is inconsistent and undermines release readiness. Node services still target Node 18 while infrastructure is shifting to Node 20; major packages lag multiple versions; Flutter dependencies are manually pinned, causing `flutter pub get` failures; and the frontend build stack does not match the roadmap. Engineers face tooling confusion because npm, pnpm, and yarn instructions coexist without a single source of truth. Build pipelines rebuild dependencies from scratch, native modules fail on Apple Silicon, and license visibility is opaque. Peer dependency conflicts continue to flood install logs, supply-chain hardening is absent (no signature enforcement, no SBOM), and optional native builds frequently break CI. Integrations are hindered by the lack of npm workspaces, unversioned shared utilities, and unpinned infrastructure providers. Security is jeopardised by unresolved CVEs, missing provenance controls, and credentials embedded in third-party SDKs. These issues collectively block scaling, introduce legal exposure, and delay alignment with platform engineering initiatives such as unified observability.

## Data Layer
The database design is not ready for multi-region operations or regulatory scrutiny. Core tables lack `region_id` attributes and partitioning strategies, preventing the upcoming regional marketplace launch. There are no audit trails for financial objects, no data retention tooling to support GDPR requests, and no materialised views to serve analytics dashboards. Developers struggle with heavyweight seed scripts, undocumented migration dependencies, missing schema documentation, and shared credentials across environments; compounding matters, `backend-nodejs/sql/install.sql` still stands up a MySQL database with default credentials instead of Postgres/PostGIS, so local testing diverges from production from day one. Rollbacks fail because down migrations drop structures without restoration, models diverge from actual constraints, and there is no automated data quality monitoring. Integration points suffer from tight coupling between API responses and database schemas, missing CDC feeds for marketing warehouses, manual payment reconciliation, and absent search indexing pipelines. Security controls are underdeveloped—PII remains plaintext, database users are overprivileged, audit logging is missing, and TLS is not enforced in-cluster. Alignment risks include incomplete evidence storage for compliance, no capacity plan for 5x growth, and lack of regional segregation to honour EU data residency commitments.

## Web Front-End
The React application cannot deliver the 1.50 experience today. Regional marketplace toggles, compliance dashboards, and real-time updates are unimplemented or placeholder-only. Admin workflows lack actionable forms, new locales are not provisioned, and there is no instrumentation for Core Web Vitals. Navigation is overcrowded, accessibility violations exceed enterprise tolerances, and tablet layouts break marketing hero sections. Routing is inconsistent: `src/App.jsx` duplicates `/provider/storefront` and `/enterprise/panel` routes (once protected, once public) and omits a catch-all fallback, so stale URLs fall into blank pages. Error handling is weak: API failures produce silent blanks, state is split across Redux and Zustand without ownership, key pages lack tests, and feature toggles evaluated in `src/providers/FeatureToggleProvider.jsx` are seeded via `Math.random()` without stable cohorts while the provider caches raw toggle payloads in `sessionStorage`. The application shell also lacks resilience—`src/main.jsx` bootstraps `<App />` without any error boundary or hydration guard, so a single lazy load failure crashes the entire UI with no recovery path. Integration with backend contracts is brittle because casing mismatches go unnormalised, analytics stubs are inactive, shared design tokens are duplicated, and feature flags rely on build-time environment variables. Security concerns include storing tokens in `localStorage` via `src/hooks/useSession.js`, minimal input sanitisation, verbose dev tooling in production builds, and absent CSP guidance. The interface is misaligned with brand, performance OKRs, accessibility commitments, and support tooling expectations, and `src/main.jsx` has not been modernised for the planned suspense-driven experiments.

## Mobile User App
The Flutter app trails significantly behind the 1.50 requirements. New marketplace filters, compliance badges, and dispute flows are missing, while push notifications remain non-functional due to incomplete backend registration. Offline persistence evaporates after app restarts, and there is no crash reporting to support field diagnostics. Onboarding contains multi-screen friction with no progress indicators, navigation breaks Android back-button semantics, and accessibility fails large-text testing. Runtime stability is compromised by Android 14 crashes, generic network error surfaces, deprecated theming APIs, and sparse logging. Integration readiness is poor: the client hits legacy endpoints only, lacks remote configuration, diverges from web analytics schemas, and ships outdated payment SDKs without 3DS2. Security posture is inadequate because tokens live in shared preferences, there is no root/jailbreak detection, TLS settings remain permissive, and logging can leak PII; additionally `lib/app/bootstrap.dart` seeds demo access tokens into the auth store and prints provider updates in release logs. Alignment gaps persist across roadmap parity, design system convergence, performance targets, support instrumentation, and localisation readiness, while `_NavigationDestination.blog` in `lib/app/app.dart` remains unreachable, signalling a widening parity gap between mobile and web navigation.

## Cross-Cutting Themes
Across all surfaces we observe systemic issues: feature parity with the 1.50 roadmap is far from met; environments are inconsistent and lack tooling support; error handling and observability are insufficient to run enterprise workloads; integrations with third parties are synchronous or untested; security hygiene does not meet compliance expectations; and operational artefacts (runbooks, contracts, documentation) lag behind product commitments. Immediate prioritisation and coordinated remediation plans are required to avoid delaying the 1.50 launch.
